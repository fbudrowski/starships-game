"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const selenium_webdriver_1 = require("selenium-webdriver");
// TODO: This is needed for the getRect() fix (see below).
// tslint:disable-next-line:no-var-requires
const command = require('selenium-webdriver/lib/command');
/**
 * Represents a ClientRect obtained via selenium-webdriver.
 */
class WebElementRect {
    constructor(rect) {
        this.rect = rect;
    }
    get width() { return this.rect.width; }
    get height() { return this.rect.height; }
    get top() { return this.rect.y; }
    get bottom() { return this.rect.y + this.rect.height; }
    get left() { return this.rect.x; }
    get right() { return this.rect.x + this.rect.width; }
}
// A version of `new WebElementCondition` that doesn't complain about correct types.
function makeWebElementCondition(message, fn) {
    // The cast of `fn` is a hack to placate selenium's poor typings.
    return new selenium_webdriver_1.WebElementCondition(message, fn);
}
async function findContentHelper(driver, finder, selector, contentRE) {
    const elem = await findContentIfPresent(driver, finder, selector, contentRE);
    if (!elem) {
        throw new selenium_webdriver_1.error.NoSuchElementError(`No elements match ${selector} and ${contentRE}`);
    }
    return elem;
}
async function findContentIfPresent(driver, finder, selector, contentRE) {
    // tslint:disable:no-shadowed-variable
    return await driver.executeScript(() => {
        const finder = (arguments[0] || window.document);
        const elements = [...finder.querySelectorAll(arguments[1])];
        const contentRE = new RegExp(arguments[2]);
        return elements.find((el) => contentRE.test(el.innerText));
    }, finder, selector, contentRE.source);
}
async function findClosestHelper(driver, finder, selector) {
    // tslint:disable:no-shadowed-variable
    const elem = await driver.executeScript(() => {
        const finder = arguments[0];
        const selector = arguments[1];
        return finder.closest(selector);
    }, finder, selector);
    if (!elem) {
        throw new selenium_webdriver_1.error.NoSuchElementError(`No ancestor elements match ${selector}`);
    }
    return elem;
}
// Enhance WebDriver to implement IWebDriverPlus interface.
Object.assign(selenium_webdriver_1.WebDriver.prototype, {
    find(selector) {
        return this.findElement(selenium_webdriver_1.By.css(selector));
    },
    async findAll(selector, mapper) {
        const elems = await this.findElements(selenium_webdriver_1.By.css(selector));
        return mapper ? Promise.all(elems.map(mapper)) : elems;
    },
    findWait(timeoutSec, selector, message) {
        return this.wait(selenium_webdriver_1.until.elementLocated(selenium_webdriver_1.By.css(selector)), timeoutSec * 1000, message);
    },
    findContent(selector, contentRE) {
        return new selenium_webdriver_1.WebElementPromise(this, findContentHelper(this, null, selector, contentRE));
    },
    findContentWait(timeoutSec, selector, contentRE, message) {
        const condition = makeWebElementCondition(`for element matching ${selector} and ${contentRE}`, () => findContentIfPresent(this, null, selector, contentRE));
        return this.wait(condition, timeoutSec * 1000, message);
    },
    mouseDown(button = selenium_webdriver_1.Button.LEFT) {
        return this.withActions((actions) => actions.press(button));
    },
    mouseUp(button = selenium_webdriver_1.Button.LEFT) {
        return this.withActions((actions) => actions.release(button));
    },
    mouseMoveBy(params = {}) {
        return this.withActions((actions) => actions.move(Object.assign({ origin: 'pointer' }, params)));
    },
    sendKeys(...keys) {
        return this.withActions((actions) => actions.sendKeys(...keys));
    },
    withActions(cb) {
        // Unfortunately selenium-webdriver typings at this point (Nov'18) are one major version behind,
        // and actions are incorrect.
        // {bridge: true} allows support for legacy actions, currently needed for Chrome (Jan'19).
        const actions = this.actions({ bridge: true });
        cb(actions);
        return actions.perform();
    },
});
// Enhance WebElement to implement IWebElementPlus interface.
Object.assign(selenium_webdriver_1.WebElement.prototype, {
    find(selector) {
        return this.findElement(selenium_webdriver_1.By.css(selector));
    },
    async findAll(selector, mapper) {
        const elems = await this.findElements(selenium_webdriver_1.By.css(selector));
        return mapper ? Promise.all(elems.map(mapper)) : elems;
    },
    findWait(timeoutSec, selector, message) {
        const condition = makeWebElementCondition(`for element matching ${selector}`, () => this.findElements(selenium_webdriver_1.By.css(selector)).then((e) => e[0]));
        return this.getDriver().wait(condition, timeoutSec * 1000, message);
    },
    findContent(selector, contentRE) {
        return new selenium_webdriver_1.WebElementPromise(this.getDriver(), findContentHelper(this.getDriver(), this, selector, contentRE));
    },
    findContentWait(timeoutSec, selector, contentRE, message) {
        const condition = makeWebElementCondition(`for element matching ${selector} and ${contentRE}`, () => findContentIfPresent(this.getDriver(), this, selector, contentRE));
        return this.getDriver().wait(condition, timeoutSec * 1000, message);
    },
    findClosest(selector) {
        return new selenium_webdriver_1.WebElementPromise(this.getDriver(), findClosestHelper(this.getDriver(), this, selector));
    },
    doClick() {
        return new selenium_webdriver_1.WebElementPromise(this.getDriver(), this.click().then(() => this));
    },
    doSendKeys(...args) {
        return new selenium_webdriver_1.WebElementPromise(this.getDriver(), this.sendKeys(...args).then(() => this));
    },
    doSubmit() {
        return new selenium_webdriver_1.WebElementPromise(this.getDriver(), this.submit().then(() => this));
    },
    doClear() {
        return new selenium_webdriver_1.WebElementPromise(this.getDriver(), this.clear().then(() => this));
    },
    value() {
        return this.getAttribute('value');
    },
    async describe() {
        const [elemId, id, tagName, classAttr] = await Promise.all([
            this.getId(), this.getAttribute('id'), this.getTagName(), this.getAttribute('class'),
        ]);
        const idStr = id ? '#' + id : '';
        const classes = classAttr ? '.' + classAttr.replace(/ /g, '.') : '';
        return `${tagName}${idStr}${classes}[${elemId}]`;
    },
    // As of 4.0.0-alpha.1, selenium-webdriver mistakenly swallows errors in getRect(). We override
    // the implementation to fix that. TODO: Remove this when fixed in selenium-webdriver. The code
    // below is copy pasted from selenium-webdriver's WebElement.getRect() (NOT WebDriver.getRect),
    // but adds a `throw err` at end of catch block, which omission is clearly a mistake.
    async getRect() {
        try {
            return await this.execute_(new command.Command(command.Name.GET_ELEMENT_RECT));
        }
        catch (err) {
            if (err instanceof selenium_webdriver_1.error.UnknownCommandError) {
                const { width, height } = await this.execute_(new command.Command(command.Name.GET_ELEMENT_SIZE));
                const { x, y } = await this.execute_(new command.Command(command.Name.GET_ELEMENT_LOCATION));
                return { x, y, width, height };
            }
            throw err;
        }
    },
    async rect() {
        return new WebElementRect(await this.getRect());
    },
    mouseMove(params = {}) {
        const p = this.getDriver().withActions((actions) => actions.move(Object.assign({ origin: this }, params)));
        return new selenium_webdriver_1.WebElementPromise(this.getDriver(), p.then(() => this));
    },
    async hasFocus() {
        const active = this.getDriver().switchTo().activeElement();
        const [a, b] = await Promise.all([this.getId(), active.getId()]);
        return a === b;
    },
    async isPresent() {
        try {
            await this.getId();
            return true;
        }
        catch (e) {
            if (e.name === 'NoSuchElementError') {
                return false;
            }
            throw e;
        }
    },
});
//# sourceMappingURL=webdriver-plus.js.map